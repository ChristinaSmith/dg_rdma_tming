//
// Generated by Bluespec Compiler, version 2013.01.beta5 (build 30325, 2013-01-23)
//
// On Sun Jun 23 18:26:34 CDT 2013
//
// Method conflict info:
// Method: frameAck1_put
// Conflict-free: frameAck2_put, ackEgress_get
// Conflicts: frameAck1_put
//
// Method: frameAck2_put
// Conflict-free: frameAck1_put, ackEgress_get
// Conflicts: frameAck2_put
//
// Method: ackEgress_get
// Conflict-free: frameAck1_put, frameAck2_put
// Conflicts: ackEgress_get
//
//
// Ports:
// Name                         I/O  size props
// RDY_frameAck1_put              O     1 reg
// RDY_frameAck2_put              O     1 reg
// ackEgress_get                  O   134 reg
// RDY_ackEgress_get              O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// frameAck1_put                  I    16 reg
// frameAck2_put                  I    16 reg
// EN_frameAck1_put               I     1
// EN_frameAck2_put               I     1
// EN_ackEgress_get               I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAckAggregatorDM1(CLK,
			  RST_N,

			  frameAck1_put,
			  EN_frameAck1_put,
			  RDY_frameAck1_put,

			  frameAck2_put,
			  EN_frameAck2_put,
			  RDY_frameAck2_put,

			  EN_ackEgress_get,
			  ackEgress_get,
			  RDY_ackEgress_get);
  input  CLK;
  input  RST_N;

  // action method frameAck1_put
  input  [15 : 0] frameAck1_put;
  input  EN_frameAck1_put;
  output RDY_frameAck1_put;

  // action method frameAck2_put
  input  [15 : 0] frameAck2_put;
  input  EN_frameAck2_put;
  output RDY_frameAck2_put;

  // actionvalue method ackEgress_get
  input  EN_ackEgress_get;
  output [133 : 0] ackEgress_get;
  output RDY_ackEgress_get;

  // signals for module outputs
  wire [133 : 0] ackEgress_get;
  wire RDY_ackEgress_get, RDY_frameAck1_put, RDY_frameAck2_put;

  // register fsCnt
  reg [15 : 0] fsCnt;
  wire [15 : 0] fsCnt_D_IN;
  wire fsCnt_EN;

  // ports of submodule ackEgressF
  wire [133 : 0] ackEgressF_D_IN, ackEgressF_D_OUT;
  wire ackEgressF_CLR,
       ackEgressF_DEQ,
       ackEgressF_EMPTY_N,
       ackEgressF_ENQ,
       ackEgressF_FULL_N;

  // ports of submodule fidIngressF1
  wire [15 : 0] fidIngressF1_D_IN, fidIngressF1_D_OUT;
  wire fidIngressF1_CLR,
       fidIngressF1_DEQ,
       fidIngressF1_EMPTY_N,
       fidIngressF1_ENQ,
       fidIngressF1_FULL_N;

  // ports of submodule fidIngressF2
  wire [15 : 0] fidIngressF2_D_IN, fidIngressF2_D_OUT;
  wire fidIngressF2_CLR,
       fidIngressF2_DEQ,
       fidIngressF2_EMPTY_N,
       fidIngressF2_ENQ,
       fidIngressF2_FULL_N;

  // ports of submodule numFrmsF
  wire [15 : 0] numFrmsF_D_IN;
  wire numFrmsF_CLR, numFrmsF_DEQ, numFrmsF_ENQ;

  // rule scheduling signals
  wire CAN_FIRE_RL_sendAck,
       CAN_FIRE_ackEgress_get,
       CAN_FIRE_frameAck1_put,
       CAN_FIRE_frameAck2_put,
       WILL_FIRE_RL_sendAck,
       WILL_FIRE_ackEgress_get,
       WILL_FIRE_frameAck1_put,
       WILL_FIRE_frameAck2_put;

  // remaining internal signals
  wire [87 : 0] DONTCARE_CONCAT_0_2_CONCAT_1_CONCAT_IF_fidIngr_ETC___d24;

  // action method frameAck1_put
  assign RDY_frameAck1_put = fidIngressF1_FULL_N ;
  assign CAN_FIRE_frameAck1_put = fidIngressF1_FULL_N ;
  assign WILL_FIRE_frameAck1_put = EN_frameAck1_put ;

  // action method frameAck2_put
  assign RDY_frameAck2_put = fidIngressF2_FULL_N ;
  assign CAN_FIRE_frameAck2_put = fidIngressF2_FULL_N ;
  assign WILL_FIRE_frameAck2_put = EN_frameAck2_put ;

  // actionvalue method ackEgress_get
  assign ackEgress_get = ackEgressF_D_OUT ;
  assign RDY_ackEgress_get = ackEgressF_EMPTY_N ;
  assign CAN_FIRE_ackEgress_get = ackEgressF_EMPTY_N ;
  assign WILL_FIRE_ackEgress_get = EN_ackEgress_get ;

  // submodule ackEgressF
  FIFO2 #(.width(32'd134), .guarded(32'd1)) ackEgressF(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(ackEgressF_D_IN),
						       .ENQ(ackEgressF_ENQ),
						       .DEQ(ackEgressF_DEQ),
						       .CLR(ackEgressF_CLR),
						       .D_OUT(ackEgressF_D_OUT),
						       .FULL_N(ackEgressF_FULL_N),
						       .EMPTY_N(ackEgressF_EMPTY_N));

  // submodule fidIngressF1
  FIFO2 #(.width(32'd16), .guarded(32'd1)) fidIngressF1(.RST(RST_N),
							.CLK(CLK),
							.D_IN(fidIngressF1_D_IN),
							.ENQ(fidIngressF1_ENQ),
							.DEQ(fidIngressF1_DEQ),
							.CLR(fidIngressF1_CLR),
							.D_OUT(fidIngressF1_D_OUT),
							.FULL_N(fidIngressF1_FULL_N),
							.EMPTY_N(fidIngressF1_EMPTY_N));

  // submodule fidIngressF2
  FIFO2 #(.width(32'd16), .guarded(32'd1)) fidIngressF2(.RST(RST_N),
							.CLK(CLK),
							.D_IN(fidIngressF2_D_IN),
							.ENQ(fidIngressF2_ENQ),
							.DEQ(fidIngressF2_DEQ),
							.CLR(fidIngressF2_CLR),
							.D_OUT(fidIngressF2_D_OUT),
							.FULL_N(fidIngressF2_FULL_N),
							.EMPTY_N(fidIngressF2_EMPTY_N));

  // submodule numFrmsF
  FIFO2 #(.width(32'd16), .guarded(32'd1)) numFrmsF(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(numFrmsF_D_IN),
						    .ENQ(numFrmsF_ENQ),
						    .DEQ(numFrmsF_DEQ),
						    .CLR(numFrmsF_CLR),
						    .D_OUT(),
						    .FULL_N(),
						    .EMPTY_N());

  // rule RL_sendAck
  assign CAN_FIRE_RL_sendAck =
	     fidIngressF1_EMPTY_N ?
	       ackEgressF_FULL_N && fidIngressF1_EMPTY_N :
	       !fidIngressF2_EMPTY_N || ackEgressF_FULL_N ;
  assign WILL_FIRE_RL_sendAck = CAN_FIRE_RL_sendAck ;

  // register fsCnt
  assign fsCnt_D_IN = fsCnt + 16'd1 ;
  assign fsCnt_EN =
	     WILL_FIRE_RL_sendAck &&
	     (fidIngressF1_EMPTY_N || fidIngressF2_EMPTY_N) ;

  // submodule ackEgressF
  assign ackEgressF_D_IN =
	     { DONTCARE_CONCAT_0_2_CONCAT_1_CONCAT_IF_fidIngr_ETC___d24,
	       fsCnt[15:8],
	       38'h1084108815 } ;
  assign ackEgressF_ENQ =
	     WILL_FIRE_RL_sendAck &&
	     (fidIngressF1_EMPTY_N || fidIngressF2_EMPTY_N) ;
  assign ackEgressF_DEQ = EN_ackEgress_get ;
  assign ackEgressF_CLR = 1'b0 ;

  // submodule fidIngressF1
  assign fidIngressF1_D_IN = frameAck1_put ;
  assign fidIngressF1_ENQ = EN_frameAck1_put ;
  assign fidIngressF1_DEQ = WILL_FIRE_RL_sendAck && fidIngressF1_EMPTY_N ;
  assign fidIngressF1_CLR = 1'b0 ;

  // submodule fidIngressF2
  assign fidIngressF2_D_IN = frameAck2_put ;
  assign fidIngressF2_ENQ = EN_frameAck2_put ;
  assign fidIngressF2_DEQ =
	     WILL_FIRE_RL_sendAck && !fidIngressF1_EMPTY_N &&
	     fidIngressF2_EMPTY_N ;
  assign fidIngressF2_CLR = 1'b0 ;

  // submodule numFrmsF
  assign numFrmsF_D_IN = 16'h0 ;
  assign numFrmsF_ENQ = 1'b0 ;
  assign numFrmsF_DEQ = 1'b0 ;
  assign numFrmsF_CLR = 1'b0 ;

  // remaining internal signals
  assign DONTCARE_CONCAT_0_2_CONCAT_1_CONCAT_IF_fidIngr_ETC___d24 =
	     { 64'hAAAAAAAAAAAA0001,
	       fidIngressF1_EMPTY_N ?
		 fidIngressF1_D_OUT[7:0] :
		 fidIngressF2_D_OUT[7:0],
	       fidIngressF1_EMPTY_N ?
		 fidIngressF1_D_OUT[15:8] :
		 fidIngressF2_D_OUT[15:8],
	       fsCnt[7:0] } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        fsCnt <= `BSV_ASSIGNMENT_DELAY 16'd1000;
      end
    else
      begin
        if (fsCnt_EN) fsCnt <= `BSV_ASSIGNMENT_DELAY fsCnt_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fsCnt = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_sendAck && fidIngressF1_EMPTY_N)
	$display("AckAggregator: ack sent for frame %0x",
		 $unsigned(fidIngressF1_D_OUT));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_sendAck && !fidIngressF1_EMPTY_N &&
	  fidIngressF2_EMPTY_N)
	$display("AckAggregator: ack sent for frame %0x",
		 $unsigned(fidIngressF2_D_OUT));
  end
  // synopsys translate_on
endmodule  // mkAckAggregatorDM1

